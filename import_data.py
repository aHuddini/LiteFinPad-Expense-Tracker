"""
Import Data Module for LiteFinPad v3.2
=======================================

Handles importing expense data from JSON backup files.

This module provides:
- JSON backup file validation
- Expense data restoration from backups
- Merge strategy (combine with existing data, no duplicates)
- Month folder creation for new months
"""

import os
import json
import hashlib
from datetime import datetime
from typing import Dict, List, Tuple, Optional
from tkinter import messagebox, filedialog
from error_logger import log_info, log_warning, log_error


class DataImporter:
    """Handle importing expense data from JSON backup files"""
    
    def __init__(self, expense_tracker):
        """
        Initialize the importer with reference to main expense tracker
        
        Args:
            expense_tracker: The main ExpenseTracker instance
        """
        self.expense_tracker = expense_tracker
    
    def generate_data_checksum(self, data: Dict) -> str:
        """
        Generate SHA-256 checksum for data verification
        
        Args:
            data: Dictionary to hash
            
        Returns:
            str: Hex string of SHA-256 hash
        """
        # Convert to stable JSON string (sorted keys for consistency)
        json_str = json.dumps(data, sort_keys=True)
        return hashlib.sha256(json_str.encode()).hexdigest()
    
    def verify_backup_integrity(self, backup_data: Dict) -> Tuple[bool, str]:
        """
        Verify backup file integrity using signature and checksum
        
        Args:
            backup_data: Parsed backup JSON data
            
        Returns:
            Tuple[bool, str]: (is_valid, error_message)
        """
        # Check for app signature
        if backup_data.get("app_signature") != "LiteFinPad-Official":
            return False, "File not generated by LiteFinPad (missing or invalid signature)"
        
        # Check for data_integrity section
        data_integrity = backup_data.get("data_integrity")
        if not data_integrity:
            return False, "Missing data integrity information"
        
        # Verify algorithm
        if data_integrity.get("algorithm") != "SHA256":
            return False, f"Unsupported integrity algorithm: {data_integrity.get('algorithm')}"
        
        # Get stored checksum
        stored_checksum = data_integrity.get("checksum")
        if not stored_checksum:
            return False, "Missing integrity checksum"
        
        # Calculate actual checksum from months data
        calculated_checksum = self.generate_data_checksum(backup_data.get("months", {}))
        
        # Compare checksums
        if calculated_checksum != stored_checksum:
            log_error(f"Checksum mismatch: stored={stored_checksum[:16]}..., calculated={calculated_checksum[:16]}...")
            return False, "Checksum mismatch - file has been modified or corrupted"
        
        log_info(f"Backup integrity verified successfully (checksum: {calculated_checksum[:16]}...)")
        return True, "Integrity verified"
    
    def import_from_json_backup(self, filepath: Optional[str] = None) -> bool:
        """
        Import data from JSON backup file
        
        Args:
            filepath: Optional path to backup file. If None, shows file picker.
        
        Returns:
            bool: True if import successful, False otherwise
        """
        try:
            # If no filepath provided, ask user to select file
            if not filepath:
                filepath = filedialog.askopenfilename(
                    title="Select Backup File to Import",
                    filetypes=[("JSON Backup", "*.json"), ("All files", "*.*")],
                    initialdir="."
                )
                
                if not filepath:
                    return False  # User cancelled
            
            log_info(f"Attempting to import backup from: {filepath}")
            
            # Load and validate backup file
            with open(filepath, 'r') as f:
                backup_data = json.load(f)
            
            # Validate backup structure
            is_valid, error_message = self.validate_backup_file(backup_data)
            if not is_valid:
                messagebox.showerror(
                    "Invalid Backup File",
                    f"The selected file is not a valid LiteFinPad backup.\n\n"
                    f"Error: {error_message}"
                )
                return False
            
            # Verify backup integrity (signature + checksum)
            is_valid_integrity, integrity_error = self.verify_backup_integrity(backup_data)
            if not is_valid_integrity:
                messagebox.showerror(
                    "Backup Integrity Check Failed",
                    f"This backup file has failed integrity verification.\n\n"
                    f"Reason: {integrity_error}\n\n"
                    f"The file may have been modified, corrupted, or was not generated by LiteFinPad.\n"
                    f"Import has been blocked for your protection."
                )
                log_error(f"Backup integrity verification failed: {integrity_error}")
                return False
            
            # Show import confirmation dialog
            confirmed = self.show_import_confirmation(backup_data)
            if not confirmed:
                return False
            
            # Perform the import (always use merge mode)
            success = self.restore_all_months(backup_data, merge_mode="merge")
            
            if success:
                # Reload current month's data to reflect changes
                self.expense_tracker.load_data()
                
                # Update UI
                if hasattr(self.expense_tracker, 'gui'):
                    self.expense_tracker.gui.update_display()
                
                # Update tray tooltip
                if hasattr(self.expense_tracker, 'update_tray_tooltip'):
                    self.expense_tracker.update_tray_tooltip()
                
                log_info("Import completed successfully")
                messagebox.showinfo(
                    "Import Successful",
                    f"Expense data imported successfully!\n\n"
                    f"Imported {backup_data['total_expenses']} expenses "
                    f"from {backup_data['total_months']} month(s).\n\n"
                    f"All data has been merged with existing expenses."
                )
                return True
            else:
                return False
                
        except FileNotFoundError:
            log_error(f"Backup file not found: {filepath}", None)
            messagebox.showerror(
                "File Not Found",
                f"Could not find backup file:\n{filepath}"
            )
            return False
            
        except json.JSONDecodeError as e:
            log_error(f"Invalid JSON in backup file: {filepath}", e)
            messagebox.showerror(
                "Invalid File Format",
                f"The selected file is not a valid JSON file.\n\n"
                f"Error: {str(e)}"
            )
            return False
            
        except Exception as e:
            log_error(f"Error importing backup from {filepath}", e)
            messagebox.showerror(
                "Import Error",
                f"Failed to import backup file.\n\n"
                f"Error: {str(e)}\n\n"
                f"Check logs/error_log.txt for details."
            )
            return False
    
    def validate_backup_file(self, data: dict) -> Tuple[bool, str]:
        """
        Validate backup file structure and integrity
        
        Args:
            data: Parsed backup JSON
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        # Check required top-level fields
        required_fields = ["app_version", "backup_date", "backup_type", "months"]
        for field in required_fields:
            if field not in data:
                return False, f"Missing required field: {field}"
        
        # Check backup type
        if data["backup_type"] != "full":
            return False, f"Unsupported backup type: {data['backup_type']}"
        
        # Check months structure
        if not isinstance(data["months"], dict):
            return False, "'months' must be a dictionary"
        
        if len(data["months"]) == 0:
            return False, "Backup contains no month data"
        
        # Validate each month's data
        for month_key, month_data in data["months"].items():
            # Check month format (YYYY-MM)
            try:
                datetime.strptime(month_key, "%Y-%m")
            except ValueError:
                return False, f"Invalid month format: {month_key} (expected YYYY-MM)"
            
            # Check month data structure
            if "expenses" not in month_data:
                return False, f"Month {month_key} missing 'expenses' field"
            
            if not isinstance(month_data["expenses"], list):
                return False, f"Month {month_key}: 'expenses' must be a list"
            
            # Validate each expense
            for idx, expense in enumerate(month_data["expenses"]):
                if not isinstance(expense, dict):
                    return False, f"Month {month_key}: expense {idx} is not a dictionary"
                
                # Check required expense fields
                if "date" not in expense:
                    return False, f"Month {month_key}: expense {idx} missing 'date'"
                if "amount" not in expense:
                    return False, f"Month {month_key}: expense {idx} missing 'amount'"
                if "description" not in expense:
                    return False, f"Month {month_key}: expense {idx} missing 'description'"
                
                # Validate amount is numeric and positive
                try:
                    amount = float(expense["amount"])
                    if amount <= 0:
                        return False, f"Month {month_key}: expense {idx} has non-positive amount (${amount})"
                except (ValueError, TypeError):
                    return False, f"Month {month_key}: expense {idx} has invalid amount"
                
                # Validate description length (if provided)
                description = expense.get("description", "")
                if description and len(description) > 500:  # Sanity check if description exists
                    return False, f"Month {month_key}: expense {idx} has description too long (>{500} chars)"
                
                # Validate date format and reasonable range
                try:
                    expense_date = datetime.strptime(expense["date"], "%Y-%m-%d")
                    
                    # Check date is in reasonable range (2000-2100)
                    if expense_date.year < 2000 or expense_date.year > 2100:
                        return False, f"Month {month_key}: expense {idx} has date outside reasonable range ({expense['date']})"
                    
                except ValueError:
                    return False, f"Month {month_key}: expense {idx} has invalid date format"
        
        return True, ""
    
    def show_import_confirmation(self, backup_data: dict) -> bool:
        """
        Show confirmation dialog with backup summary
        
        Args:
            backup_data: Parsed backup JSON
        
        Returns:
            bool: True if user confirmed, False if cancelled
        """
        month_list = sorted(backup_data["months"].keys())
        month_summary = ", ".join(month_list)
        
        backup_date_str = backup_data.get("backup_date", "Unknown")
        try:
            backup_date = datetime.fromisoformat(backup_date_str)
            backup_date_formatted = backup_date.strftime("%B %d, %Y at %I:%M %p")
        except:
            backup_date_formatted = backup_date_str
        
        message = (
            f"Import expense data from backup?\n\n"
            f"Backup Information:\n"
            f"• Created: {backup_date_formatted}\n"
            f"• Version: {backup_data.get('app_version', 'Unknown')}\n"
            f"• Total Months: {backup_data['total_months']}\n"
            f"• Total Expenses: {backup_data['total_expenses']}\n"
            f"• Grand Total: ${backup_data.get('grand_total', 0.0):.2f}\n\n"
            f"Months: {month_summary}\n\n"
            f"Import Mode: MERGE\n"
            f"(Existing expenses will be kept, backup data will be added)"
        )
        
        return messagebox.askyesno(
            "Confirm Import",
            message,
            icon='question'
        )
    
    def restore_all_months(self, backup_data: dict, merge_mode: str = "merge") -> bool:
        """
        Restore months from backup
        
        Args:
            backup_data: Parsed backup JSON
            merge_mode: "merge" (combines with existing, no duplicates)
        
        Returns:
            bool: True if restore successful
        """
        try:
            restored_months = []
            
            for month_key, month_data in backup_data["months"].items():
                log_info(f"Restoring month: {month_key}")
                
                # Create data folder if it doesn't exist
                data_folder = f"data_{month_key}"
                os.makedirs(data_folder, exist_ok=True)
                
                expenses_file = os.path.join(data_folder, "expenses.json")
                backup_expenses = month_data["expenses"]
                
                # Merge mode: combine with existing data
                if os.path.exists(expenses_file):
                    # Load existing expenses
                    with open(expenses_file, 'r') as f:
                        existing_data = json.load(f)
                    
                    existing_expenses = existing_data.get('expenses', [])
                    
                    # Merge expenses (avoid duplicates)
                    merged_expenses = self.merge_expenses(existing_expenses, backup_expenses)
                    
                    log_info(f"Month {month_key}: Merged {len(existing_expenses)} existing + "
                            f"{len(backup_expenses)} backup = {len(merged_expenses)} total")
                else:
                    # No existing data, use backup data directly
                    merged_expenses = backup_expenses
                    log_info(f"Month {month_key}: Created new with {len(merged_expenses)} expenses")
                
                # Calculate monthly total (excluding future dates)
                today = datetime.now().date()
                monthly_total = sum(
                    expense['amount'] for expense in merged_expenses
                    if datetime.strptime(expense['date'], '%Y-%m-%d').date() <= today
                )
                
                # Save merged data
                save_data = {
                    'expenses': merged_expenses,
                    'monthly_total': monthly_total
                }
                
                with open(expenses_file, 'w') as f:
                    json.dump(save_data, f, indent=2)
                
                log_info(f"Month {month_key}: Saved {len(merged_expenses)} expenses, total ${monthly_total:.2f}")
                restored_months.append(month_key)
            
            log_info(f"Successfully restored {len(restored_months)} months: {restored_months}")
            return True
            
        except Exception as e:
            log_error("Error during month restoration", e)
            messagebox.showerror(
                "Restore Error",
                f"Failed to restore expense data.\n\n"
                f"Error: {str(e)}\n\n"
                f"Some data may have been partially imported.\n"
                f"Check logs/error_log.txt for details."
            )
            return False
    
    def merge_expenses(self, existing: List[Dict], backup: List[Dict]) -> List[Dict]:
        """
        Merge two expense lists, avoiding duplicates
        
        Duplicate detection: Same date, amount, and description
        
        Args:
            existing: List of existing expense dicts
            backup: List of backup expense dicts
        
        Returns:
            List of merged expense dicts
        """
        # Create merged list starting with existing expenses
        merged = existing.copy()
        
        # Track existing expenses by (date, amount, description) tuple
        existing_signatures = set()
        for expense in existing:
            signature = (
                expense.get('date', ''),
                expense.get('amount', 0.0),
                expense.get('description', '')
            )
            existing_signatures.add(signature)
        
        # Add backup expenses that don't already exist
        duplicates_skipped = 0
        for expense in backup:
            signature = (
                expense.get('date', ''),
                expense.get('amount', 0.0),
                expense.get('description', '')
            )
            
            if signature not in existing_signatures:
                merged.append(expense)
                existing_signatures.add(signature)
            else:
                duplicates_skipped += 1
        
        if duplicates_skipped > 0:
            log_info(f"Skipped {duplicates_skipped} duplicate expenses during merge")
        
        # Sort merged expenses by date (newest first)
        merged.sort(key=lambda x: x.get('date', ''), reverse=True)
        
        return merged


def import_expense_backup(expense_tracker, filepath: Optional[str] = None):
    """
    Convenience function to import expense backup
    
    Args:
        expense_tracker: The main ExpenseTracker instance
        filepath: Optional path to backup file
    """
    importer = DataImporter(expense_tracker)
    return importer.import_from_json_backup(filepath)

